#!/usr/bin/python

"""
    Arista Desktop Transcoder (GTK+ client)
    =======================================
    An audio/video transcoder based on simple device profiles provided by
    presets. This is the GTK+ version.
    
    License
    -------
    Copyright 2008 - 2011 Daniel G. Taylor <dan@programmer-art.org>
    
    This file is part of Arista.

    Arista is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as 
    published by the Free Software Foundation, either version 2.1 of
    the License, or (at your option) any later version.

    Arista is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with Arista.  If not, see
    <http://www.gnu.org/licenses/>.
"""

import gettext
import locale
import logging
import os
import re
import shutil
import sys
import threading
import time
import webbrowser

from optparse import OptionParser

import gobject
import gio
import gconf
import cairo
import gtk

# FIXME: Stupid hack, see the other fixme comment below!
if __name__ != "__main__":
    import gst

_log = logging.getLogger("arista-gtk")

try:
    import pynotify
    pynotify.init("icon-summary-body")
except ImportError:
    pynotify = None
    _log.info("Unable to import pynotify - desktop notifications disabled")

try:
    import webkit
except ImportError:
    webkit = None
    _log.info("Unable to import webkit - in-app documentation disabled")

import arista

_ = gettext.gettext

locale.setlocale(locale.LC_ALL, '')

CONFIG_PATH = "/apps/arista"

DEFAULT_CHECK_INPUTS = True
DEFAULT_SHOW_TOOLBAR = True
DEFAULT_SHOW_PREVIEW = True
DEFAULT_PREVIEW_FPS = 10
DEFAULT_CHECK_UPDATES = True
DEFAULT_OPEN_PATH = os.path.expanduser("~/Desktop")

RE_ENDS_NUM = re.compile(r'^.*(?P<number>[0-9]+)$')

def _new_combo_with_image(extra = []):
    """
        Create a new combo box with a list store of a pixbuf, a string, and any
        extra passed types.
        
        @type extra: list
        @param extra: Extra types to add to the gtk.ListStore
        @rtype: gtk.ComboBox
            @return: The newly created combo box
    """
    store = gtk.ListStore(gtk.gdk.Pixbuf, gobject.TYPE_STRING, *extra)
    combo = gtk.ComboBox(store)
    pixbuf_cell = gtk.CellRendererPixbuf()
    text_cell = gtk.CellRendererText()
    combo.pack_start(pixbuf_cell, False)
    combo.pack_start(text_cell, True)
    combo.add_attribute(pixbuf_cell, 'pixbuf', 0)
    combo.add_attribute(text_cell, 'text', 1)
    return combo

def _get_icon_pixbuf(uri, width, height):
    """
        Get a pixbuf from an item with an icon URI set.
        
        @type item: object
        @param item: An object with an icon attribute
        @type width: int
        @param width: The requested width of the pixbuf
        @type height: int
        @param height: The requested height of the pixbuf
        @rtype: gtk.Pixbuf or None
        @return: The pixbuf of the icon if it can be found
    """
    image = None
    theme = gtk.icon_theme_get_default()
    
    if not uri:
        return image
    
    if uri.startswith("file://"):
        try:
            path = arista.utils.get_path("presets", uri[7:])
        except IOError:
            path = ""
        
        if os.path.exists(path):
            image = gtk.gdk.pixbuf_new_from_file_at_size(path, width, height)
    elif uri.startswith("stock://"):
        image = theme.load_icon(uri[8:], gtk.ICON_SIZE_MENU, 0)
    else:
        raise ValueError(_("Unknown icon URI %(uri)s") % {
            "uri": uri
        })
    
    return image

def _get_filename_icon(filename):
    """
        Get the icon from a filename using GIO.
        
            >>> icon = _get_filename_icon("test.mp4")
            >>> if icon:
            >>>     # Do something here using icon.load_icon()
            >>>     ...
        
        @type filename: str
        @param filename: The name of the file whose icon to fetch
        @rtype: gtk.ThemedIcon or None
        @return: The requested unloaded icon or nothing if it cannot be found
    """
    theme = gtk.icon_theme_get_default()
    
    names = gio.content_type_get_icon(gio.content_type_guess(filename)).get_property("names")
    icon = theme.choose_icon(names, gtk.ICON_SIZE_MENU, 0)
    
    return icon

class UpdateChecker(threading.Thread):
    """
        A thread to check for updates on startup.
    """
    def __init__(self, main):
        """
            @type main: MainWindow
            @param main: The main Arista window
        """
        self.main = main
        
        super(UpdateChecker, self).__init__()
    
    def run(self):
        """
            Check for updates and present the user with the option of
            installing any updated presets, then install them if she chooses
            to. After the installation another dialog is shown asking to
            restart the program.
        """
        client = gconf.client_get_default()
        
        try:
            last_check = client.get_value(CONFIG_PATH + "/last_update_check")
        except ValueError:
            last_check = 0
        
        # Let's not hammer the server - wait minimum of an hour between checks
        if time.time() - last_check < 60 * 60:
            return
        
        # Set last update check time
        client.set_value(CONFIG_PATH + "/last_update_check", time.time())
        
        # Do the update checks
        updates = arista.presets.check_for_updates()
        if updates:
            gtk.gdk.threads_enter()
            dialog = gtk.MessageDialog(parent = self.main.window,
                type = gtk.MESSAGE_QUESTION,
                buttons = gtk.BUTTONS_YES_NO,
                message_format = _("There are %(count)d new or updated " \
                                   "device presets available. Install " \
                                   "them now?") % {
                    "count": len(updates),
            })
            result = dialog.run()
            dialog.hide()
            gtk.gdk.threads_leave()
            
            if result == gtk.RESPONSE_YES:
                devices = []
                
                for loc, name in updates:
                    devices += arista.presets.fetch(loc, name)
                
                for device in devices:
                    icon = arista.utils.get_path("presets/" + arista.presets.get()[device].icon[7:])
                    notice = pynotify.Notification(_("Update Successful"), _("Device preset %(name)s successfully updated.") % {
                        "name": arista.presets.get()[device],
                    }, icon)
                    notice.show()
            
                gtk.gdk.threads_enter()
                dialog.destroy()
                
                arista.presets.reset()
                self.main.setup_devices()
                gtk.gdk.threads_leave()
            else:
                gtk.gdk.threads_enter()
                dialog.destroy()
                gtk.gdk.threads_leave()

class LogoWidget(gtk.Widget):
    """
        A widget to show the Arista logo.
        
        See http://svn.gnome.org/viewvc/pygtk/trunk/examples/gtk/widget.py?view=markup
    """
    def __init__(self):
        gtk.Widget.__init__(self)
        
        # Load the logo overlay
        logo_path = arista.utils.get_path("ui", "logo.svg")
        self.pixbuf = gtk.gdk.pixbuf_new_from_file(logo_path)
    
    def do_realize(self):
        """
            Realize the widget. Setup the window.
        """
        self.set_flags(self.flags() | gtk.REALIZED)
        
        self.window = gtk.gdk.Window(
            self.get_parent_window(),
            width = self.allocation.width,
            height = self.allocation.height,
            window_type = gtk.gdk.WINDOW_CHILD,
            wclass = gtk.gdk.INPUT_OUTPUT,
            event_mask = self.get_events() | gtk.gdk.EXPOSURE_MASK)
        
        self.window.set_user_data(self)
        
        self.style.attach(self.window)
        
        self.style.set_background(self.window, gtk.STATE_NORMAL)
        self.window.move_resize(*self.allocation)
        
        self.gc = self.style.fg_gc[gtk.STATE_NORMAL]
    
    def do_unrealize(self):
        """
            Destroy the window.
        """
        self.window.destroy()
    
    def do_size_request(self, requisition):
        """
            Request a minimum size.
        """
        requisition.width = self.pixbuf.get_width()
        requisition.height = self.pixbuf.get_height()
    
    def do_size_allocate(self, allocation):
        """
            Our size was allocated, save it!
        """
        self.allocation = allocation
        
        if self.flags() & gtk.REALIZED:
            self.window.move_resize(*allocation)
    
    def do_expose_event(self, event):
        """
            Draw the logo.
        """
        x, y, w, h = self.allocation
        
        cr = self.window.cairo_create()
        
        # Base the background color on a 50% luminosity version of the theme's
        # selected color (the color you usually see in progress bars, for
        # example) and make the gradient go from slightly lighter to slightly
        # darker.
        color = self.style.bg[gtk.STATE_SELECTED]
        r, g, b = color.red / 65535.0, color.green / 65535.0, \
                  color.blue / 65535.0
        avg = (r + g + b) / 3.0
        r, g, b = [i + 0.5 - avg for i in [r, g, b]]
        
        # Draw a gradient background
        gradient = cairo.LinearGradient(0, 0, 0, h)
        gradient.add_color_stop_rgb(0.0, r * 1.1, g * 1.1, b * 1.1)
        gradient.add_color_stop_rgb(1.0, r, g, b)
        
        cr.rectangle(0, 0, w, h)
        cr.set_source(gradient)
        cr.fill()
        
        # Draw block shadow area
        gradient = cairo.LinearGradient(1, (h / 2) + 5, 1, (h / 2) + 115)
        gradient.add_color_stop_rgba(0.0, r * 0.95, g * 0.95, b * 0.95, 0.0)
        gradient.add_color_stop_rgba(0.5, r * 0.95, g * 0.95, b * 0.95, 1.0)
        gradient.add_color_stop_rgba(0.6, r * 0.9, g * 0.9, b * 0.9, 1.0)
        gradient.add_color_stop_rgba(1.0, r * 0.9, g * 0.9, b * 0.9, 0.0)
        
        cr.rectangle(1, (h / 2) + 5, w - 2, 30)
        cr.rectangle(1, (h / 2) + 35 + 45, w - 2, 35)
        cr.set_source(gradient)
        cr.fill()
        
        # Draw a highlighted block
        cr.set_source_rgba(1.0, 1.0, 1.0, 0.13)
        cr.rectangle(1, (h / 2) + 35, w - 2, 45)
        cr.fill()
        
        # Draw a border around the highlighted block
        cr.rectangle(1, (h / 2) + 35, w - 2, 1)
        cr.rectangle(1, (h / 2) + 35 + 45 - 1, w - 2, 1)
        cr.fill()
        
        # Draw the outer border
        cr.set_source_rgba(0.0, 0.0, 0.0, 0.5)
        cr.set_line_width(1.0)
        cr.rectangle(0, 0, w, h)
        cr.stroke()
        
        # Draw the logo svg centered in the widget
        self.window.draw_pixbuf(self.gc, self.pixbuf, 0, 0,
                                (w / 2) - (self.pixbuf.get_width() / 2),
                                (h / 2) - (self.pixbuf.get_height() / 2))

gobject.type_register(LogoWidget)

class MainWindow(object):
    """
        Arista Main Window
        ==================
        The main transcoder window. Provides a method of selecting a source,
        output device, and preset for transcoding as well as managing the
        transcoding queue.
    """
    def __init__(self, runoptions):
        self.runoptions = runoptions
        
        ui_path = arista.utils.get_path("ui", "main.ui")
        
        # Load the GUI
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        self.builder.connect_signals(self)
        
        self.window = self.builder.get_object("main_window")
        self.menuitem_toolbar = self.builder.get_object("menuitem_toolbar")
        self.toolbar = self.builder.get_object("toolbar")
        self.toolbutton_remove = self.builder.get_object("toolbutton_remove")
        self.toolbutton_pause = self.builder.get_object("toolbutton_pause")
        self.hbox_progress = self.builder.get_object("hbox_progress")
        self.progress = self.builder.get_object("progressbar")
        self.button_pause = self.builder.get_object("button_pause")
        self.button_cancel = self.builder.get_object("button_cancel")
        self.preview = self.builder.get_object("video_preview")
        self.preview_frame = self.builder.get_object("preview_frame")
        
        self.image_preview = gtk.Alignment(xscale = 1.0, yscale = 1.0)
        self.image_preview.set_padding(0, 5, 0, 0)
        self.image_preview.add(LogoWidget())
        self.builder.get_object("vbox_preview").pack_start(self.image_preview)
        
        self.add_dialog = None
        self.prefs_dialog = None
        self.about_dialog = None
        
        self.transcoder = None
        
        # Setup the transcoding queue and watch for events
        self.queue = arista.queue.TranscodeQueue()
        self.queue.connect("entry-discovered", self.on_queue_entry_discovered)
        self.queue.connect("entry-error", self.on_queue_entry_error)
        self.queue.connect("entry-complete", self.on_queue_entry_complete)
        
        # Setup configuration system
        client = gconf.client_get_default()
        
        client.add_dir(CONFIG_PATH, gconf.CLIENT_PRELOAD_NONE)
        
        # Update UI to reflect currently stored settings
        try:
            value = client.get_value(CONFIG_PATH + "/show_toolbar")
            if value:
                self.toolbar.show()
            else:
                self.toolbar.hide()
            self.menuitem_toolbar.set_active(value)
        except ValueError:
            if DEFAULT_SHOW_TOOLBAR:
                self.toolbar.show()
            else:
                self.toolbar.hide()
            self.menuitem_toolbar.set_active(DEFAULT_SHOW_TOOLBAR)
        
        client.notify_add(CONFIG_PATH + "/show_toolbar", 
                          self.on_gconf_show_toolbar)
        
        try:
            value = client.get_value(CONFIG_PATH + "/last_open_path")
            if value and os.path.exists(value):
                self.last_open_path = value
            else:
                self.last_open_path = DEFAULT_OPEN_PATH
        except ValueError:
            self.last_open_path = DEFAULT_OPEN_PATH
        
        # Show the interface!
        self.preview.hide()
        self.hbox_progress.hide()
        self.image_preview.show_all()
        self.window.show()
        
        # Are we using the simplified interface? Hide stuff!
        if self.runoptions.simple:
            self.builder.get_object("menubar").hide()
            self.toolbar.hide()
            self.window.resize(320, 240)
            self.window.set_position(gtk.WIN_POS_CENTER_ALWAYS)
            
            device = arista.presets.get()[self.runoptions.device]
        
            if not self.runoptions.preset:
                preset = device.presets[device.default]
            else:
                for (id, preset) in device.presets.items():
                    if preset.name == options.preset:
                        break
            
            outputs = []
            for fname in self.runoptions.files:
                output = arista.utils.generate_output_path(fname, preset,
                             to_be_created=outputs,
                             device_name=self.runoptions.device)
            
                outputs.append(output)
            
                opts = arista.transcoder.TranscoderOptions(fname, preset, output)
            
                self.queue.append(opts)
    
    def on_quit(self, widget, *args):
        """
            Stop the transcoder and hopefully let it cleanup, then exit.
        """
        try:
            if self.transcoder:
                if self.transcoder.state in [gst.STATE_READY, gst.STATE_PAUSED]:
                    self.transcoder.start()
                    
                self.transcoder.pipe.send_event(gst.event_new_eos())
        except:
            pass
        
        self.window.hide()
        
        _log.debug(_("Cleaning up and flushing buffers..."))
        
        def waiting_to_quit():
            if not self.transcoder or self.transcoder.state == gst.STATE_NULL:
                gobject.idle_add(gtk.main_quit)
                return False
            else:
                return True
        
        gobject.idle_add(waiting_to_quit)
        
        return True
    
    def on_pause_toggled(self, widget):
        """
            Pause toolbar button clicked.
        """
        if widget.get_active():
            self.transcoder.pause()
        else:
            self.transcoder.start()
    
    def on_add(self, widget):
        """
            Add an item to the queue. This shows a file chooser dialog to 
            pick the output filename and then adds the item to the queue for
            transcoding.
        """
        if self.add_dialog:
            if self.add_dialog.window.get_property("visible"):
                self.add_dialog.window.present()
                return
            else:
                self.add_dialog.window.destroy()
        
        self.add_dialog = AddDialog(self)
        return
        iter = self.presets.get_active_iter()
        preset = self.presets.get_model().get_value(iter, 2)
        
        self.source.set_sensitive(False)
        self.devices.set_sensitive(False)
        self.presets.set_sensitive(False)
        
        can_encode = preset.check_elements(self.preset_ready)

    def preset_ready(self, preset, can_encode):
        """
            Called when a preset is ready to be encoded after checking for
            (and optionally installing) required GStreamer elements.
        """
        gtk.gdk.threads_enter()
        self.source.set_sensitive(True)
        self.devices.set_sensitive(True)
        self.presets.set_sensitive(True)
        gtk.gdk.threads_leave()
        
        if not can_encode:
            gtk.gdk.threads_enter()
            dialog = gtk.MessageDialog(self.window, type = gtk.MESSAGE_ERROR, buttons = gtk.BUTTONS_OK, message_format = _("Cannot add item to queue because of missing elements!"))
            dialog.run()
            dialog.destroy()
            gtk.gdk.threads_leave()
            return
        
        gtk.gdk.threads_enter()
        if isinstance(self.source, gtk.ComboBox):
            iter = self.source.get_active_iter()
            model = self.source.get_model()
            inpath = model.get_value(iter, 2)
            inname = os.path.basename(inpath)
        else:
            inpath = self.source.get_filename()
            inname = os.path.basename(inpath)
        iter = self.devices.get_active_iter()
        device = self.devices.get_model().get_value(iter, 2)
        
        filenames = []
        if not os.path.isdir(inpath):
            default_out = self.get_default_output_name(inpath, preset)
            dialog = gtk.FileChooserDialog(title = _("Choose Output File..."),
                        action = gtk.FILE_CHOOSER_ACTION_SAVE,
                        buttons = (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                                   gtk.STOCK_SAVE, gtk.RESPONSE_ACCEPT))
            dialog.set_property("local-only", False)
            dialog.set_property("do-overwrite-confirmation", True)
            dialog.set_current_folder(os.path.dirname(inpath))
            dialog.set_current_name(os.path.basename(default_out))
            response = dialog.run()
            dialog.hide()
            if response == gtk.RESPONSE_ACCEPT:
                filenames.append((inpath, dialog.get_filename()))
        else:
            dialog = gtk.FileChooserDialog(title = _("Choose Output Directory..."),
                        action = gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER,
                        buttons = (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                                   gtk.STOCK_SAVE, gtk.RESPONSE_ACCEPT))
            dialog.set_property("local-only", False)
            dialog.set_property("do-overwrite-confirmation", True)
            dialog.set_current_folder(inpath)
            response = dialog.run()
            dialog.hide()
            if response == gtk.RESPONSE_ACCEPT:
                outdir = dialog.get_current_folder()
                for root, dirs, files in os.walk(inpath):
                    for fname in files:
                        full_path = os.path.join(root, fname)
                        filenames.append((full_path, os.path.join(outdir, os.path.basename(self.get_default_output_name(full_path, preset)))))
        
        for inpath, outpath in filenames:
            # Setup the transcode job options
            self.options.uri = inpath
            self.options.preset = preset
            self.options.output_uri = outpath
            
            self.queue.append(self.options)
            
            # Reset options for next item, but copy relevant data
            options = arista.transcoder.TranscoderOptions()
            options.subfile = self.options.subfile
            options.font = self.options.font
            options.deinterlace = self.options.deinterlace
            self.options = options
            
            iter = self.queue_model.append()
            width, height = gtk.icon_size_lookup(gtk.ICON_SIZE_MENU)
            image = _get_icon_pixbuf(device.icon, width, height)
            if image:
                self.queue_model.set_value(iter, 0, image)
            self.queue_model.set_value(iter, 1, _("%(model)s (%(preset)s): %(filename)s") % {
                "model": device.model,
                "preset": preset.name,
                "filename": os.path.basename(outpath),
            })
            self.queue_model.set_value(iter, 2, self.queue[-1])
        
        # Reset the options for the next item so we don't inadvertently
        # change the queued option data!
        self.options = arista.transcoder.TranscoderOptions()
        
        gtk.gdk.threads_leave()
    
    def stop_processing_entry(self, entry):
        """
            Stop processing an entry that is currently being processed. This
            sends an end-of-stream signal down the pipe, hides the preview,
            and makes sure the menu and toolbar is in the proper state.
            
            The item will remain in the queue for up to a few seconds as 
            GStreamer finishes flushing its buffers, then will be removed.
            If another item is in the queue it will start processing then.
        """
        entry.stop()
        
        if self.runoptions.simple and len(self.queue) == 1:
            # This is the last item in the simplified GUI, so we are done and
            # should exit as soon as possible!
            gobject.idle_add(gtk.main_quit)
            return
        
        # Hide live preview while we wait for the item to finish
        self.image_preview.show()
        self.preview.hide()
        self.hbox_progress.hide()
    
    def on_about(self, widget):
        """
            Show the about dialog.
        """
        AboutDialog()
    
    def on_prefs(self, widget):
        """
            Show the preferences dialog.
        """
        PrefsDialog()
    
    def on_show_toolbar_toggled(self, widget):
        """
            Update the GConf preference for showing or hiding the toolbar.
        """
        client = gconf.client_get_default()
        client.set_bool(CONFIG_PATH + "/show_toolbar", widget.get_active())
    
    def on_gconf_show_toolbar(self, client, connection, entry, args):
        """
            Show or hide the toolbar and set the menu item to reflect which
            has happened when the GConf preference has changed.
        """
        self.menuitem_toolbar.set_active(entry.get_value().get_bool())
        if entry.get_value().get_bool():
            self.toolbar.show()
        else:
            self.toolbar.hide()
    
    def on_queue_entry_discovered(self, queue, entry, info, is_media):
        """
            The queue entry has been discovered, see if it is a valid input
            file, if not show an error and remove it from the queue.
        """
        if not info.is_video and info.is_audio:
            _log.error(_("Input %(infile)s contains no valid streams!") % {
                "infile": entry.transcoder.infile,
            })
            
            gtk.gdk.threads_enter()
            
            msg = "The input file or device contains no audio or video " \
                  "streams and will be removed from the queue."
            
            dialog = gtk.MessageDialog(self.window,
                            gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                            type = gtk.MESSAGE_ERROR,
                            buttons = gtk.BUTTONS_OK,
                            message_format = msg)
            dialog.set_title(_("Error with input!"))
            dialog.run()
            dialog.destroy()
            gtk.gdk.threads_leave()
            self.on_queue_entry_complete(queue, entry)
        else:
            entry.transcoder.connect("pass-setup",
                                     self.on_queue_entry_pass_setup, entry)
    
    def on_queue_entry_pass_setup(self, transcoder, entry):
        """
            Called by the queue to start an entry. Setup the correct pass and
            start the transcoder after attaching to the video tee so that
            we can show a nice preview.
        """
        client = gconf.client_get_default()
        
        try:
            show_preview = client.get_value(CONFIG_PATH + "/show_preview")
        except ValueError:
            show_preview = DEFAULT_SHOW_PREVIEW
        
        try:
            fps = client.get_value(CONFIG_PATH + "/preview_fps")
        except ValueError:
            fps = DEFAULT_PREVIEW_FPS
        
        transcoder = entry.transcoder
        self.transcoder = transcoder
        gobject.timeout_add(500, self.on_status_update)
        
        if show_preview:
            element = transcoder.pipe.get_by_name("videotee")
            
            if element:
                pipe = gst.parse_launch("queue name=preview_source ! decodebin2 ! videoscale method=bilinear ! videorate ! ffmpegcolorspace ! video/x-raw-yuv, framerate=%d/1; video/x-raw-rgb, framerate=%d/1 ! autovideosink name=preview_sink" % (fps, fps))
                psink = pipe.get_by_name("preview_sink")
                psink.connect("element-added", self.on_preview_sink_element_added)
                transcoder.pipe.add(pipe)
                src = pipe.get_by_name("preview_source")
                gst.element_link_many(element, src)
                bus = transcoder.pipe.get_bus()
                bus.enable_sync_message_emission()
                bus.connect("sync-message::element", self.on_sync_msg)
                self.preview.show()
                self.image_preview.hide()
        
        self.hbox_progress.show()
    
    def on_queue_entry_error(self, queue, entry, error_str):
        """
            An entry in the queue has had an error. Update the queue model
            and inform the user.
        """
        entry.transcoder.stop()
        
        if pynotify and not entry.force_stopped:
            theme = gtk.icon_theme_get_default()
            icon_info = theme.lookup_icon("dialog-error", 64, 0)
            if icon_info:
                icon = icon_info.get_filename()
            else:
                icon = ""
            notice = pynotify.Notification(_("Error!"), _("Conversion of %(filename)s to %(device)s %(preset)s failed! Reason: %(reason)s") % {
                "filename": os.path.basename(entry.options.output_uri),
                "device": entry.options.preset.device,
                "preset": entry.options.preset.name,
                "reason": error_str,
            }, icon)
            notice.show()
        else:
            # TODO: Show a dialog or something for people with no notifications
            pass
        
        if self.runoptions.simple and len(self.queue) == 1:
            # This is the last item in the simplified GUI, so we are done and
            # should exit as soon as possible!
            gobject.idle_add(gtk.main_quit)
            return
        
        self.image_preview.show()
        self.preview.hide()
        self.hbox_progress.hide()
    
    def on_queue_entry_complete(self, queue, entry):
        """
            An entry in the queue is finished. Update the queue model.
        """
        if pynotify:
            try:
                icon = arista.utils.get_path("presets/" + entry.options.preset.device.icon[7:])
            except IOError:
                icon = ""
            
            notice = pynotify.Notification(_("Job done"), _("Conversion of %(filename)s to %(device)s %(preset)s %(action)s") % {
                "filename": os.path.basename(entry.options.output_uri),
                "device": entry.options.preset.device.name,
                "preset": entry.options.preset.name,
                "action": entry.force_stopped and _("canceled") or _("finished")
            }, icon)
            notice.show()
        
        if self.runoptions.simple and len(self.queue) == 1:
            # This is the last item in the simplified GUI, so we are done and
            # should exit as soon as possible!
            gobject.idle_add(gtk.main_quit)
            return
        
        self.image_preview.show()
        self.preview.hide()
        self.hbox_progress.hide()
    
    def on_preview_sink_element_added(self, autovideosink, element):
        """
            Since we let Gstreamer decide which video sink to use, whenever it
            has picked one set the sync attribute to false so that the
            transcoder runs as fast as possible.
        """
        try:
            # We don't want to play at the proper speed, just go as fast
            # as possible when encoding!
            element.set_property("sync", False)
        except: pass
    
    def on_sync_msg(self, bus, msg):
        """
            Prepare the preview drawing area so that the video preview is 
            rendered there.
        """
        if msg.structure is None:
            return
            
        msg_name = msg.structure.get_name()
        if msg_name == "prepare-xwindow-id":
            gtk.gdk.threads_enter()
            imagesink = msg.src
            imagesink.set_property("force-aspect-ratio", True)
            imagesink.set_xwindow_id(self.preview.window.xid)
            gtk.gdk.threads_leave()
    
    def on_status_update(self):
        """
            Update the status progress bar and text.
        """
        percent = 0.0
        state = self.transcoder.state
        
        if state != gst.STATE_PAUSED:
            try:
                percent, time_rem = self.transcoder.status
                
                if percent > 1.0:
                    percent = 1.0
                if percent < 0.0:
                    percent = 0.0
                
                pass_info = ""
                if self.transcoder.preset.pass_count > 1:
                    pass_info = "pass %(pass)d of %(total)d, " % {
                        "pass": self.transcoder.enc_pass + 1,
                        "total": self.transcoder.preset.pass_count,
                    }
                
                time_info = "%(time)s remaining" % {
                    "time": time_rem,
                }
                
                file_info = ""
                if len(self.queue) > 1:
                    file_info = ", %(files)d files left" % {
                        "files": len(self.queue)
                    }
                
                info_string = "Transcoding... (%(pass_info)s%(time_info)s%(file_info)s)" % {
                    "pass_info": pass_info,
                    "time_info": time_info,
                    "file_info": file_info,
                }
                
                gtk.gdk.threads_enter()
                
                if percent == 0.0:
                    self.progress.pulse()
                else:
                    self.progress.set_fraction(percent)
                
                self.progress.set_text(info_string)
                gtk.gdk.threads_leave()
            except arista.transcoder.TranscoderStatusException, e:
                _log.debug(str(e))
                self.progress.pulse()
        
        return percent < 1.0 and state != gst.STATE_NULL
    
    def on_cancel_clicked(self, widget):
        """
            The user clicked the stop button, so stop processing the entry.
        """
        if len(self.queue):
            self.stop_processing_entry(self.queue[0])
    
    def on_install_device(self, widget):
        dialog = gtk.FileChooserDialog(title=_("Choose Source File..."),
                        buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                                 gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT))
        dialog.set_property("local-only", False)
        dialog.set_current_folder(self.last_open_path)
        response = dialog.run()
        dialog.hide()
        if response == gtk.RESPONSE_ACCEPT:
            filename = dialog.get_filename()
            client = gconf.client_get_default()
            client.set_string(CONFIG_PATH + "/last_open_path",
                              os.path.dirname(filename))
            devices = arista.presets.extract(open(filename))
            arista.presets.reset()
            self.setup_devices()
            if pynotify:
                for device in devices:
                    icon = arista.utils.get_path("presets/" + arista.presets.get()[device].icon[7:])
                    notice = pynotify.Notification(_("Installation Successful"), _("Device preset %(name)s successfully installed.") % {
                        "name": arista.presets.get()[device],
                    }, icon)
                    notice.show()

class PrefsDialog(object):
    """
        Arista Preferences Dialog
        =========================
        A dialog to edit preferences and presets.
    """
    def __init__(self):
        ui_path = arista.utils.get_path("ui", "prefs.ui")
        
        # Load the interface definition file
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        
        # Shortcuts for accessing widgets
        self.window = self.builder.get_object("prefs_dialog")
        self.check_inputs = self.builder.get_object("check_inputs")
        self.check_show_live = self.builder.get_object("check_show_live")
        self.check_updates = self.builder.get_object("check_updates")
        self.spin_live_fps = self.builder.get_object("spin_live_fps")
        
        # Setup configuration system
        client = gconf.client_get_default()
        
        client.add_dir(CONFIG_PATH, gconf.CLIENT_PRELOAD_NONE)
        
        # Update UI to reflect currently stored settings
        try:
            value = client.get_value(CONFIG_PATH + "/check_inputs")
            self.check_inputs.set_active(value)
        except ValueError:
            self.check_inputs.set_active(DEFAULT_CHECK_INPUTS)
        
        try:
            value = client.get_value(CONFIG_PATH + "/show_preview")
            self.check_show_live.set_active(value)
        except ValueError:
            self.check_show_live.set_active(DEFAULT_SHOW_PREVIEW)
        
        try:
            value = client.get_value(CONFIG_PATH + "/preview_fps")
            self.spin_live_fps.set_value(value)
        except ValueError:
            self.spin_live_fps.set_value(DEFAULT_PREVIEW_FPS)
        
        try:
            value = client.get_value(CONFIG_PATH + "/check_updates")
            self.check_updates.set_active(value)
        except ValueError:
            self.check_updates.set_active(DEFAULT_CHECK_UPDATES)
        
        # Register handlers for when settings are changed
        client.notify_add(CONFIG_PATH + "/check_inputs", 
                          self.on_gconf_check_inputs)
        client.notify_add(CONFIG_PATH + "/show_preview", 
                          self.on_gconf_show_preview)
        client.notify_add(CONFIG_PATH + "/preview_fps", 
                          self.on_gconf_preview_fps)
        client.notify_add(CONFIG_PATH + "/check_updates",
                          self.on_gconf_check_updates)
        
        # Connect to signals defined in UI definition file
        self.builder.connect_signals(self)
        
        # Show the window and go!
        self.window.show_all()
    
    def on_close(self, widget, response):
        """
            Close was clicked, remove the window.
        """
        self.window.destroy()
    
    def on_check_inputs_toggled(self, widget):
        """
            Update GConf preference for checking DVD drives.
        """
        client = gconf.client_get_default()
        client.set_bool(CONFIG_PATH + "/check_inputs", widget.get_active())
    
    def on_check_show_live_toggled(self, widget):
        """
            Update GConf preference for showing a live preview during encoding.
        """
        client = gconf.client_get_default()
        client.set_bool(CONFIG_PATH + "/show_preview", widget.get_active())
    
    def on_fps_changed(self, widget):
        """
            Update GConf preference for the frames per second to show during
            the live preview. The higher the number the more CPU is diverted
            from encoding to displaying the video.
        """
        client = gconf.client_get_default()
        client.set_int(CONFIG_PATH + "/preview_fps", int(widget.get_value()))
    
    def on_check_updates_toggled(self, widget):
        """
            Update GConf preference for checking online for updated presets.
            If enabled the application will check on launch for updated presets
            and ask the user to install them.
        """
        client = gconf.client_get_default()
        client.set_bool(CONFIG_PATH + "/check_updates", widget.get_active())
    
    def on_gconf_check_inputs(self, client, connection, entry, args):
        """
            Update UI when the GConf preference for checking DVD drives has
            been modified.
        """
        self.check_inputs.set_active(entry.get_value().get_bool())
    
    def on_gconf_show_preview(self, client, connection, entry, args):
        """
            Update UI when the GConf preference for showing the live preview
            has been modified.
        """
        value = entry.get_value().get_bool()
        
        self.check_show_live.set_active(value)
        self.spin_live_fps.set_sensitive(value)
    
    def on_gconf_preview_fps(self, client, connection, entry, args):
        """
            Update UI when the GConf preference for the preview framerate has
            been modified.
        """
        self.spin_live_fps.set_value(entry.get_value().get_int())
    
    def on_gconf_check_updates(self, client, connection, entry, args):
        """
            Update the UI when the GConf preference for checking for updates
            has been modified.
        """
        self.check_updates.set_active(entry.get_value().get_bool())

class PropertiesDialog(object):
    """
        Arista Source Properties Dialog
        ===============================
        A simple dialog to set properties for the input source, such as
        subtitles and deinterlacing.
    """
    def __init__(self, options):
        self.options = options
    
        ui_path = arista.utils.get_path("ui", "props.ui")
        
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        
        self.window = self.builder.get_object("props_dialog")
        self.subs = self.builder.get_object("filechooserbutton_subs")
        self.font = self.builder.get_object("fontbutton")
        self.deinterlace = self.builder.get_object("checkbutton_deinterlace")
        
        if options.subfile:
            self.subs.set_filename(options.subfile)
        
        if options.font:
            self.font.set_font_name(options.font)
        
        if options.deinterlace:
            self.deinterlace.set_active(options.deinterlace)
        
        self.builder.connect_signals(self)
        
        self.window.show_all()
    
    def on_close(self, widget, response):
        """
            Close was clicked, remove the window.
        """
        self.window.destroy()
    
    def on_subs_set(self, widget):
        """
            Set subtitle file.
        """
        self.options.subfile = widget.get_filename()
    
    def on_font_set(self, widget):
        """
            Set subtitle rendering font.
        """
        self.options.font = widget.get_font_name()
    
    def on_deinterlace(self, widget):
        """
            Toggle forced deinterlacing.
        """
        self.options.deinterlace = widget.get_active()

class AddDialog(object):
    """
        A dialog for creating new conversion jobs.
    """
    def __init__(self, parent):
        self.parent = parent
        
        ui_path = arista.utils.get_path("ui", "add.ui")
        
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        
        self.window = self.builder.get_object("add_dialog")
        self.presets_view = self.builder.get_object("presets_view")
        self.entry_filter = self.builder.get_object("entry_filter")
        self.button_add = self.builder.get_object("button_add")
        self.button_destination = self.builder.get_object("button_destination")
        
        self.settings_frame = self.builder.get_object("settings_frame")
        
        self.presets_model = gtk.ListStore(gtk.gdk.Pixbuf,        # Image
                                           gobject.TYPE_STRING,   # Preset
                                           gobject.TYPE_PYOBJECT) # Data
        
        self.presets_filter = self.presets_model.filter_new()
        self.presets_filter.set_visible_func(self._filter)
        
        self.presets_view.set_model(self.presets_filter)
        
        self.presets_view.get_selection().connect("changed", self.on_preset_changed)
        
        pixbuf_renderer = gtk.CellRendererPixbuf()
        preset_renderer = gtk.CellRendererText()
        
        column = gtk.TreeViewColumn(_("Device Preset"))
        column.pack_start(pixbuf_renderer, False)
        column.set_attributes(pixbuf_renderer, pixbuf = 0)
        column.pack_start(preset_renderer)
        column.set_attributes(preset_renderer, markup = 1)
        self.presets_view.append_column(column)
        
        self.source = None
        self.source_hbox = None
        self.finder = None
        self.finder_video_found = None
        self.finder_video_lost = None
        
        self.table = self.builder.get_object("settings_table")
        
        self.setup_source()
        
        gobject.idle_add(self.setup_devices)
        
        self.fileiter = None
        self.options = arista.transcoder.TranscoderOptions()
        
        # Setup configuration system
        client = gconf.client_get_default()
        
        client.add_dir(CONFIG_PATH, gconf.CLIENT_PRELOAD_NONE)
        
        try:
            value = client.get_value(CONFIG_PATH + "/last_open_path")
            if value and os.path.exists(value):
                self.last_open_path = value
            else:
                self.last_open_path = DEFAULT_OPEN_PATH
        except ValueError:
            self.last_open_path = DEFAULT_OPEN_PATH
        
        self.button_destination.set_current_folder(self.last_open_path)
        
        client.notify_add(CONFIG_PATH + "/last_open_path", 
                          self.on_gconf_last_open_path)
        client.notify_add(CONFIG_PATH + "/check_inputs", self.setup_source)
        
        self.source.show()
        
        self.builder.connect_signals(self)
        
        self.window.show_all()
    
    def setup_source(self, *args):
        """
            Setup the source widget. Creates a combo box or a file input button
            depending on the settings and available devices.
        """
        theme = gtk.icon_theme_get_default()
        size = gtk.ICON_SIZE_MENU
        
        # Already exists? Remove it!
        if self.source:
            self.source_hbox.remove(self.source)
            self.source.destroy()
        
        if self.finder:
            if self.finder_disc_found is not None:
                self.finder.disconnect(self.finder_disc_found)
                self.finder_disc_found = None
            
            if self.finder_disc_lost is not None:
                self.finder.disconnect(self.finder_disc_lost)
                self.finder_disc_lost = None
        
        # Should we check for DVD drives?
        client = gconf.client_get_default()
        try:
            check_inputs = client.get_value(CONFIG_PATH + "/check_inputs")
        except ValueError:
            check_inputs = DEFAULT_CHECK_INPUTS
        
        if check_inputs:
            # Setup input source discovery
            # Adds DVD and V4L devices to the source combo box
            if not self.finder:
                self.finder = arista.inputs.InputFinder()
                
            if len(self.finder.drives) or len(self.finder.capture_devices):
                icon = gtk.stock_lookup(gtk.STOCK_CDROM)[0]
                self.source = _new_combo_with_image([gobject.TYPE_PYOBJECT])
                model = self.source.get_model()
                
                for block, drive in self.finder.drives.items():
                    iter = model.append()
                    model.set_value(iter, 0, theme.load_icon(icon, size, 0))
                    model.set_value(iter, 1, drive.nice_label)
                    model.set_value(iter, 2, "dvd://" + block)
                
                for device, capture in self.finder.capture_devices.items():
                    iter = model.append()
                    model.set_value(iter, 0, theme.load_icon("camera-video",
                                                             size, 0))
                    model.set_value(iter, 1, capture.nice_label)
                    if capture.version == '1':
                        model.set_value(iter, 2, "v4l://" + device)
                    elif capture.version == '2':
                        model.set_value(iter, 2, "v4l2://" + device)
                    else:
                        _log.warning(_("Unknown V4L version %(version)s!") % {
                                       "version": capture.version,
                                    })
                        model.remove(iter)
                
                iter = model.append()
                icon = gtk.stock_lookup(gtk.STOCK_OPEN)[0]
                model.set_value(iter, 0, theme.load_icon(icon, size, 0))
                model.set_value(iter, 1, _("Choose File..."))
                
                iter = model.append()
                icon = gtk.stock_lookup(gtk.STOCK_OPEN)[0]
                model.set_value(iter, 0, theme.load_icon(icon, size, 0))
                model.set_value(iter, 1, _("Choose Directory..."))
                
                self.source.set_active(0)
                self.source.connect("changed", self.on_source_changed)
                
                # Watch for DVD discovery events
                self.finder_disc_found = self.finder.connect("disc-found",
                                                        self.on_disc_found)
                self.finder_disc_lost = self.finder.connect("disc-lost",
                                                        self.on_disc_lost)
            else:
                self.source = gtk.FileChooserButton(_("Choose File..."))
        else:
            self.source = gtk.FileChooserButton(_("Choose File..."))
        
        # Add properties button to set source properties like subtitles
        source_prop_image = gtk.Image()
        source_prop_image.set_from_stock(gtk.STOCK_PROPERTIES, 
                                         gtk.ICON_SIZE_MENU)
        source_properties = gtk.Button()
        source_properties.add(source_prop_image)
        source_properties.connect("clicked", self.on_source_properties)
        
        if not self.source_hbox:
            self.source_hbox = gtk.HBox()
            self.source_hbox.pack_end(source_properties, expand = False)
            self.table.attach(self.source_hbox, 1, 2, 0, 1, yoptions = gtk.FILL)
        
        self.source_hbox.pack_start(self.source)
        
        # Attach and show the source
        self.source_hbox.show_all()
    
    def setup_devices(self):
        """
            Setup the device presets view.
        """
        # Find plugins and sort them nicely
        # Adds output device profiles to the output device view
        
        width, height = 32, 32
        
        model = self.presets_view.get_model().get_model()
        
        # Remove existing items
        model.clear()
        
        self.default_device = 0
        for x, (id, device) in enumerate(sorted(arista.presets.get().items(),
                                   lambda x, y: cmp(x[1].name, y[1].name))):
            for (preset_id, preset) in sorted(device.presets.items(), lambda x, y: cmp(x[1].name, y[1].name)):
                iter = model.append()
                
                image = _get_icon_pixbuf(preset.icon or device.icon, width, height)
                
                if image:
                    model.set_value(iter, 0, image)
                
                model.set_value(iter, 1, "<b>%s - %s</b>\nUp to %sx%s" % (device.name, preset_id, preset.vcodec.width[1], preset.vcodec.height[1]))
                model.set_value(iter, 2, (device, preset))
                
                if id == "computer" and preset == device.default_preset:
                    self.default_device = iter
        
        self.presets_view.set_cursor(model.get_path(self.default_device))
        self.presets_view.scroll_to_cell(model.get_path(self.default_device))
    
    def _filter(self, model, iter):
        """
            Filter device presets view to show only presets that match the
            string typed into the filter text input box.
        """
        iter_value = model.get_value(iter, 2)
        
        if not iter_value:
            return False
        
        (device, preset) = iter_value
        search_text = self.entry_filter.get_text().lower().strip()
        
        strings = [device.name, device.description, preset.name, preset.vcodec.name, preset.acodec.name]
        
        for string in strings:
            if search_text in string.lower():
                return True
        
        return False
    
    def get_default_output_name(self, inname, preset):
        """
            Get the default recommended output filename given an input path
            and a preset. The original extension is removed, then the new
            preset extension is added. If such a path already exists then
            numbers are added before the extension until a non-existing path
            is found to exist.
        """
        if "." in inname:
            default_out = ".".join(inname.split(".")[:-1]) + "." + preset.extension
        else:
            default_out = inname + "." + preset.extension
        
        while os.path.exists(default_out):
            parts = default_out.split(".")
            name, ext = ".".join(parts[:-1]), parts[-1]
            
            result = RE_ENDS_NUM.search(name)
            if result:
                value = result.group("number")
                name = name[:-len(value)]
                number = int(value) + 1
            else:
                number = 1
                
            default_out = "%s%d.%s" % (name, number, ext)
        
        return default_out
    
    def on_filter_changed(self, widget):
        """
            Device presets view filter changed.
        """
        self.presets_filter.refilter()
    
    def on_preset_changed(self, selection):
        model, iter = selection.get_selected()
        
        self.button_add.set_sensitive(bool(iter))
    
    def on_disc_found(self, finder, device, label):
        """
            A video DVD has been found, update the source combo box!
        """
        model = self.source.get_model()
        for pos, item in enumerate(model):
            if item[2] and item[2].endswith(device.path):
                model[pos] = (item[0], device.nice_label, item[2])
                break
    
    def on_disc_lost(self, finder, device, label):
        """
            A video DVD has been removed, update the source combo box!
        """
        model = self.source.get_model()
        for pos, item in enumerate(model):
            if item[2].endswith(device.path):
                model[pos] = (item[0], device.nice_label, item[2])
                break
    
    def on_gconf_last_open_path(self, client, connection, entry, args):
        """
            Change the default location of the open dialog when choosing a 
            new file or folder to transcode.
        """
        path = entry.get_value().get_string()
        if os.path.exists(path):
            self.last_open_path = path
        else:
            self.last_open_path = DEFAULT_OPEN_PATH
        
        self.button_destination.set_current_folder(self.last_open_path)
    
    def on_source_changed(self, widget):
        """
            The source combo box or file chooser button has changed, update!
        """
        theme = gtk.icon_theme_get_default()
        size = gtk.ICON_SIZE_MENU
        width, height = gtk.icon_size_lookup(size)
        
        iter = widget.get_active_iter()
        model = widget.get_model()
        item = model.get_value(iter, 1)
        if item == _("Choose File..."):
            dialog = gtk.FileChooserDialog(title=_("Choose Source File..."),
                        buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                                 gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT))
            dialog.set_property("local-only", False)
            dialog.set_current_folder(self.last_open_path)
            response = dialog.run()
            dialog.hide()
            filename = None
            if response == gtk.RESPONSE_ACCEPT:
                if self.fileiter:
                    model.remove(self.fileiter)
                filename = dialog.get_filename()
                client = gconf.client_get_default()
                client.set_string(CONFIG_PATH + "/last_open_path",
                                  os.path.dirname(filename))
                pos = widget.get_active()
                newiter = model.insert(pos)
                icon = _get_filename_icon(filename)
                if icon:
                    model.set_value(newiter, 0, icon.load_icon())
                basename = os.path.basename(filename)
                if len(basename) > 25:
                    basename = basename[:22] + "..."
                model.set_value(newiter, 1, basename)
                model.set_value(newiter, 2, filename)
                self.fileiter = newiter
                widget.set_active(pos)
            else:
                if self.fileiter:
                    pos = widget.get_active()
                    widget.set_active(pos - 1)
                else:
                    widget.set_active(0)

            # Reset the custom input options
            self.options.reset()

            # Find a subtitle file with same filename
            if filename:
                subfilename = filename[0:filename.rfind(".")]+".srt" 
                if os.path.exists(subfilename):
                    self.options.subfile = subfilename

        elif item == _("Choose Directory..."):
            dialog = gtk.FileChooserDialog(title=_("Choose Source Directory..."),
                        action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER,
                        buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                                 gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT))
            dialog.set_property("local-only", False)
            dialog.set_current_folder(self.last_open_path)
            response = dialog.run()
            dialog.hide()
            if response == gtk.RESPONSE_ACCEPT:
                if self.fileiter:
                    model.remove(self.fileiter)
                directory = dialog.get_current_folder()
                client = gconf.client_get_default()
                client.set_string(CONFIG_PATH + "/last_open_path", directory)
                pos = widget.get_active() - 1
                newiter = model.insert(pos)
                icon = icon = _get_icon_pixbuf("stock://gtk-directory", width, height)
                model.set_value(newiter, 0, icon)
                model.set_value(newiter, 1, os.path.basename(directory.rstrip("/")))
                model.set_value(newiter, 2, directory)
                self.fileiter = newiter
                widget.set_active(pos)
            else:
                if self.fileiter:
                    pos = widget.get_active()
                    widget.set_active(pos - 2)
                else:
                    widget.set_active(0)
                
            # Reset the custom input options
            self.options.reset()
    
    def on_source_properties(self, widget):
        """
            Show source properties dialog so user can set things like
            subtitles, forcing deinterlacing, etc.
        """
        dialog = PropertiesDialog(self.options)
        dialog.window.run()
        dialog.window.destroy()
    
    def on_device_changed(self, widget):
        """
            The device combo was changed - update the presets for the newly
            selected device.
        """
        width, height = gtk.icon_size_lookup(gtk.ICON_SIZE_MENU)
        
        iter = self.devices.get_active_iter()
        
        device = self.devices.get_model().get_value(iter, 2)
        
        if isinstance(device, str):
            webbrowser.open(device)
            self.devices.set_active(self.default_device)
            return
        
        model = self.presets.get_model()
        model.clear()
        
        selected = 0
        for (pos, (name, preset)) in enumerate(device.presets.items()):
            iter = model.append()
            
            if preset.icon:
                image = _get_icon_pixbuf(preset.icon, width, height)
                
                if image:
                    model.set_value(iter, 0, image)
            
            model.set_value(iter, 1, name)
            model.set_value(iter, 2, preset)
            if device.default and device.default == preset.name:
                selected = pos
        
        self.presets.set_active(selected)
    
    def on_destination_changed(self, widget):
        pass
    
    def on_cancel(self, widget):
        self.window.destroy()
    
    def on_add(self, widget):
        model, iter = self.presets_view.get_selection().get_selected()
        
        device, preset = model.get_value(iter, 2)
        
        can_encode = preset.check_elements(self.on_preset_ready)
    
    def on_preset_ready(self, preset, can_encode):
        """
            Called when a preset is ready to be encoded after checking for
            (and optionally installing) required GStreamer elements.
        """
        gtk.gdk.threads_enter()
        
        gtk.gdk.threads_leave()
        
        if not can_encode:
            gtk.gdk.threads_enter()
            dialog = gtk.MessageDialog(self.window, type = gtk.MESSAGE_ERROR, buttons = gtk.BUTTONS_OK, message_format = _("Cannot add conversion to queue because of missing elements!"))
            dialog.run()
            dialog.destroy()
            gtk.gdk.threads_leave()
            return
        
        gtk.gdk.threads_enter()
        if isinstance(self.source, gtk.ComboBox):
            iter = self.source.get_active_iter()
            model = self.source.get_model()
            inpath = model.get_value(iter, 2)
            inname = os.path.basename(inpath)
        else:
            inpath = self.source.get_filename()
            inname = os.path.basename(inpath)
        
        filenames = []
        outdir = self.button_destination.get_current_folder()
        
        if not os.path.isdir(inpath):
            filenames.append((inpath, self.get_default_output_name(inpath, preset)))
        else:
            for root, dirs, files in os.walk(inpath):
                for fname in files:
                    full_path = os.path.join(root, fname)
                    filenames.append((full_path, os.path.join(outdir, os.path.basename(self.get_default_output_name(full_path, preset)))))
        
        for inpath, outpath in filenames:
            # Setup the transcode job options
            self.options.uri = inpath
            self.options.preset = preset
            self.options.output_uri = outpath
            
            self.parent.queue.append(self.options)
            
            # Reset options for next item, but copy relevant data
            options = arista.transcoder.TranscoderOptions()
            options.subfile = self.options.subfile
            options.font = self.options.font
            options.deinterlace = self.options.deinterlace
            self.options = options
        
        self.window.destroy()
        
        gtk.gdk.threads_leave()
    
    def on_new_clicked(self, widget):
        """
            Create a new device preset.
        """
        webbrowser.open("http://www.transcoder.org/presets/create")
    
    def on_delete_clicked(self, widget):
        """
            Delete a device preset. Asks the user if she is really sure before
            actually doing so.
        """
        model, iter = self.presets_view.get_selection().get_selected()
        device, preset = model.get_value(iter, 2)
        
        dialog = gtk.MessageDialog(self.window, type=gtk.MESSAGE_WARNING, buttons=gtk.BUTTONS_YES_NO, message_format="Are you sure you want to delete the %(preset)s preset?" % { "preset": device.name + " - " + preset.name })
        response = dialog.run()
        dialog.destroy()
        
        if response == gtk.RESPONSE_YES:
            devices = arista.presets.get()
            name = ".".join(os.path.basename(device.filename).split(".")[:-1])
            
            if len(device.presets) == 1:
                # This was the only preset, so delete the file
                del devices[name]
                
                if os.access(device.filename, os.W_OK):
                    os.unlink(device.filename)
            else:
                del device.presets[preset.name]
                if not os.access(device.filename, os.W_OK):
                    device.filename = arista.utils.get_write_path("presets", os.path.basename(device.filename))
                
                device.save()
    
    def on_info_clicked(self, widget):
        """
            Display an edit dialog allowing you to view info about and manage
            device presets.
        """
        model, iter = self.presets_view.get_selection().get_selected()
        
        device, preset = model.get_value(iter, 2)
        
        dialog = PresetDialog(preset)
        
        dialog.connect("changed", self.preset_changed, iter)
    
    def preset_changed(self, dialog, iter):
        model = self.presets_view.get_model()
        device, preset = model.get_value(iter, 2)
        
        # Convert iter/model to underlying TreeModel rather than filter
        iter = model.convert_iter_to_child_iter(iter)
        model = model.get_model()
        
        # Update text
        model.set_value(iter, 1, "<b>%s - %s</b>\nUp to %sx%s" % (device.name, preset.name, preset.vcodec.width[1], preset.vcodec.height[1]))

class PresetDialog(gobject.GObject):
    """
        Arista Preset Dialog
        ====================
        A dialog for viewing and editing preset properties.
    """
    __gsignals__ =  {
        "changed": (gobject.SIGNAL_RUN_FIRST, None, ())
    }
    
    CONTAINER_LIST = ["WebM", "MP4", "MOV", "AVI", "MPEG2 PS", "MPEG2 TS", "DVD (VOB)", "Matroska", "Ogg", "FLV"]
    MUXER_TO_CONTAINER = {
        "webmmux": 0,
        "ffmux_webm": 0,
        "mp4mux": 1,
        "ffmux_mp4": 1,
        "qtmux": 2,
        "ffmux_mov": 2,
        "avimux": 3,
        "ffmux_avi": 3,
        "mpegpsmux": 4,
        "mpegtsmux": 5,
        "ffmux_mpegts": 5,
        "ffmux_vob": 6,
        "ffmux_dvd": 6,
        "matroskamux": 7,
        "ffmux_matroska": 7,
        "oggmux": 8,
        "ffmux_ogg": 8,
        "flvmux": 9,
        "ffmux_flv": 9,
    }
    CONTAINER_TO_MUXER = {
        "WebM": "webmmux",
        "MP4": "mp4mux",
        "MOV": "qtmux",
        "AVI": "avimux",
        "MPEG2 PS": "mpegpsmux",
        "MPEG2 TS": "mpegtsmux",
        "DVD (VOB)": "ffmux_dvd",
        "Matroska": "matroskamux",
        "Ogg": "oggmux",
        "FLV": "flvmux",
    }
    ENCODER_TO_VCODEC = {
        "vp8enc": "VP8",
        "x264enc": "H.264 / AVC",
        "xvidenc": "MPEG4 / DivX / XviD",
        "mpeg2enc": "MPEG2",
        "theoraenc": "Theora",
        "ffenc_flv": "FLV / Spark / H.263",
    }
    VCODEC_TO_ENCODER = {
        "VP8": "vp8enc",
        "H.264 / AVC": "x264enc",
        "MPEG4 / DivX / XviD": "xvidenc",
        "MPEG2": "mpeg2enc",
        "Theora": "theoraenc",
        "FLV / Spark / H.263": "ffenc_flv",
    }
    ENCODER_TO_ACODEC = {
        "faac": "AAC",
        "lame": "MP3",
        "vorbisenc": "Vorbis",
        "ffenc_ac3": "AC3",
    }
    ACODEC_TO_ENCODER = {
        "Vorbis": "vorbisenc",
        "AAC": "faac",
        "MP3": "lame",
        "AC3": "ffenc_ac3",
    }
    EFFECT_LIST = ["None", "Rotate clockwise", "Rotate counter-clockwise", "Flip vertical", "Flip horizontal"]
    EFFECT_TO_ELEMENTS = {
        "None": "",
        "Rotate clockwise": "videoflip method=clockwise",
        "Rotate counter-clockwise": "videoflip method=counterclockwise",
        "Flip vertical": "videoflip method=vertical-flip",
        "Flip horizontal": "videoflip method=horizontal-flip",
    }
    ELEMENTS_TO_EFFECT = {
        "": 0,
        "videoflip method=clockwise": 1,
        "videoflip method=1": 1,
        "videoflip method=counterclockwise": 2,
        "videoflip method=3": 2,
        "videoflip method=vertical-flip": 3,
        "videoflip method=5": 3,
        "videoflip method=horizontal-flip": 4,
        "videoflip method=4": 4,
    }
    
    def __init__(self, preset):
        gobject.GObject.__init__(self)
        ui_path = arista.utils.get_path("ui", "preset.ui")
        
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        
        self.window = self.builder.get_object("preset_dialog")
        
        self.image = self.builder.get_object("image_icon")
        self.short_name = self.builder.get_object("entry_short_name")
        self.description = self.builder.get_object("entry_description")
        self.make = self.builder.get_object("entry_make")
        self.model = self.builder.get_object("entry_model")
        self.preset_name = self.builder.get_object("entry_preset")
        self.author_name = self.builder.get_object("entry_author_name")
        self.author_email = self.builder.get_object("entry_author_email")
        self.version = self.builder.get_object("entry_version")
        self.container = self.builder.get_object("combo_container")
        
        self.video_codec = self.builder.get_object("combo_video_codec")
        self.video_options = self.builder.get_object("entry_video_options")
        self.width_min = self.builder.get_object("spin_width_min")
        self.width_max = self.builder.get_object("spin_width_max")
        self.height_min = self.builder.get_object("spin_height_min")
        self.height_max = self.builder.get_object("spin_height_max")
        self.framerate_min = self.builder.get_object("spin_framerate_min")
        self.framerate_max = self.builder.get_object("spin_framerate_max")
        self.effect = self.builder.get_object("combo_effect")
        
        self.audio_codec = self.builder.get_object("combo_audio_codec")
        self.audio_options = self.builder.get_object("entry_audio_options")
        self.channels_min = self.builder.get_object("spin_channels_min")
        self.channels_max = self.builder.get_object("spin_channels_max")
        
        # Set general values
        width, height = gtk.icon_size_lookup(gtk.ICON_SIZE_DIALOG)
        image = _get_icon_pixbuf(preset.icon or preset.device.icon, width, height)
        self.image.set_from_pixbuf(image)
        
        self.short_name.set_text(".".join(os.path.basename(preset.device.filename).split(".")[:-1]))
        self.description.set_text(preset.description or preset.device.description)
        self.make.set_text(preset.device.make)
        self.model.set_text(preset.device.model)
        self.preset_name.set_text(preset.name)
        self.author_name.set_text(preset.author.name or preset.device.author.name)
        self.author_email.set_text(preset.author.email or preset.device.author.email)
        self.version.set_text(preset.version or preset.device.version)
        
        # Setup list models for combo boxes
        cstore = gtk.ListStore(gobject.TYPE_STRING)
        self.container.set_model(cstore)
        text_cell = gtk.CellRendererText()
        self.container.pack_start(text_cell, True)
        self.container.add_attribute(text_cell, 'text', 0)
        
        # Setup possible containers
        for attr in self.CONTAINER_LIST:
            iter = cstore.append()
            cstore.set_value(iter, 0, attr)
        
        vstore = gtk.ListStore(gobject.TYPE_STRING)
        self.video_codec.set_model(vstore)
        text_cell = gtk.CellRendererText()
        self.video_codec.pack_start(text_cell, True)
        self.video_codec.add_attribute(text_cell, 'text', 0)
        
        astore = gtk.ListStore(gobject.TYPE_STRING)
        self.audio_codec.set_model(astore)
        text_cell = gtk.CellRendererText()
        self.audio_codec.pack_start(text_cell, True)
        self.audio_codec.add_attribute(text_cell, 'text', 0)
        
        # Set active container
        self.container.set_active(self.MUXER_TO_CONTAINER.get(preset.container, 0))
        
        # Update codec combos to show valid codecs for selected container
        self.update_codecs(self.CONTAINER_LIST[self.MUXER_TO_CONTAINER[preset.container]])
        
        for widget, codec in [(self.video_codec, self.ENCODER_TO_VCODEC[preset.vcodec.name]), (self.audio_codec, self.ENCODER_TO_ACODEC[preset.acodec.name])]:
            for i, row in enumerate(widget.get_model()):
                if row[0] == codec:
                    widget.set_active(i)
        
        # Set codec values
        self.video_options.set_text(";".join(preset.vcodec.passes))
        self.width_min.set_value(preset.vcodec.width[0])
        self.width_max.set_value(preset.vcodec.width[1])
        self.height_min.set_value(preset.vcodec.height[0])
        self.height_max.set_value(preset.vcodec.height[1])
        self.framerate_min.set_value(preset.vcodec.rate[0])
        self.framerate_max.set_value(preset.vcodec.rate[1])
        
        self.audio_options.set_text(";".join(preset.acodec.passes))
        self.channels_min.set_value(preset.acodec.channels[0])
        self.channels_max.set_value(preset.acodec.channels[1])
        
        # Setup effects
        estore = gtk.ListStore(gobject.TYPE_STRING)
        self.effect.set_model(estore)
        text_cell = gtk.CellRendererText()
        self.effect.pack_start(text_cell, True)
        self.effect.add_attribute(text_cell, 'text', 0)
        
        for attr in self.EFFECT_LIST:
            iter = estore.append()
            estore.set_value(iter, 0, attr)
        
        effect = self.ELEMENTS_TO_EFFECT.get(preset.vcodec.transform, 5)
        # Handle custom effects we don't recognize
        if effect == 5:
            iter = estore.append()
            estore.set_value(iter, 0, "Custom")
            self.effect.set_sensitive(False)
        self.effect.set_active(effect)
        
        self.builder.connect_signals(self)
        
        self.preset = preset
        
        self.window.show_all()
    
    def on_destroy(self, widget):
        _log.debug(_("Saving preset to disk..."))
        self.preset.device.save()
    
    def on_close_clicked(self, widget):
        self.window.destroy()
    
    def on_icon_clicked(self, widget):
        # Let user select new image, copy to presets folder, possibly rename
        client = gconf.client_get_default()
        dialog = gtk.FileChooserDialog(title=_("Choose Preset Icon..."),
                    buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                             gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT))
        dialog.set_property("local-only", False)
        dialog.set_current_folder(client.get_string(CONFIG_PATH + "/last_open_path"))
        filter = gtk.FileFilter()
        filter.set_name("Image Files")
        filter.add_pattern("*.png")
        filter.add_pattern("*.svg")
        dialog.set_filter(filter)
        response = dialog.run()
        dialog.hide()
        if response == gtk.RESPONSE_ACCEPT:
            filename = dialog.get_filename()
            ext = filename.split(".")[-1]
            output = arista.utils.get_write_path("presets", self.preset.slug + "." + ext)
            shutil.copy(filename, output)
            self.preset.icon = "file://" + self.preset.slug + "." + ext
            width, height = gtk.icon_size_lookup(gtk.ICON_SIZE_DIALOG)
            image = _get_icon_pixbuf(self.preset.icon, width, height)
            self.image.set_from_pixbuf(image)
            client.set_string(CONFIG_PATH + "/last_open_path",
                              os.path.dirname(filename))
    
    def on_shortname_changed(self, widget, arg):
        # Change the filename, update icon filename if present, etc
        # This can actually be used to group multiple presets into a single
        # file. Hopefully that's not too confusing.
        old_name = ".".join(os.path.basename(self.preset.device.filename).split(".")[:-1])
        new_name = widget.get_text()
        if new_name:
            old_filename = self.preset.device.filename
            devices = arista.presets.get()
            
            if new_name in devices:
                # We are moving this preset into an existing device
                devices[new_name].presets[self.preset.name] = self.preset
            else:
                # We are creating a new device file
                devices[new_name] = arista.presets.Device(**{
                    "make": devices[old_name].make,
                    "model": devices[old_name].model,
                    "description": devices[old_name].description,
                    "author": arista.presets.Author(**{
                        "name": devices[old_name].author.name,
                        "email": devices[old_name].author.email,
                    }),
                    "version": devices[old_name].version,
                    "presets": {
                        self.preset.name: self.preset,
                    },
                    "icon": devices[old_name].icon,
                    "default": self.preset.name,
                })
                devices[new_name].filename = arista.utils.get_write_path("presets", new_name + ".json")
            
            self.preset.device = devices[new_name]
            self.make.set_text(self.preset.device.make)
            self.model.set_text(self.preset.device.model)
            
            if len(devices[old_name].presets) == 1:
                # This was the only preset, so delete the file
                del devices[old_name]
                
                if os.access(old_filename, os.W_OK):
                    os.unlink(old_filename)
            else:
                del devices[old_name].presets[self.preset.name]
                if not os.access(old_filename, os.W_OK):
                    devices[old_name].filename = arista.utils.get_write_path("presets", os.path.basename(old_filename))
                
                devices[old_name].save()
    
    def on_description_changed(self, widget):
        self.preset.description = widget.get_text()
    
    def on_make_changed(self, widget):
        self.preset.device.make = widget.get_text()
        
        self.emit("changed")
    
    def on_model_changed(self, widget):
        self.preset.device.model = widget.get_text()
        
        self.emit("changed")
    
    def on_name_changed(self, widget, arg):
        # Update device presets dictionary
        old_name = self.preset.name
        new_name = widget.get_text()
        if new_name:
            # Update default if needed
            if self.preset.device.default == old_name:
                self.preset.device.default = new_name
            # Update presets map
            del self.preset.device.presets[old_name]
            self.preset.device.presets[new_name] = self.preset
            # Set name on preset itself
            self.preset.name = new_name
            
            self.emit("changed")
    
    def on_author_name_changed(self, widget):
        self.preset.author.name = widget.get_text()
    
    def on_author_email_changed(self, widget):
        self.preset.author.email = widget.get_text()
    
    def on_version_changed(self, widget):
        self.preset.version = widget.get_text()
    
    def on_container_changed(self, widget):
        iter = self.container.get_active_iter()
        container = self.container.get_model().get_value(iter, 0)
        
        self.preset.container = self.CONTAINER_TO_MUXER[container]
        
        self.update_codecs(container)
    
    def update_codecs(self, container):
        vcodecs = {
            "WebM": ["VP8"],
            "MP4": ["H.264 / AVC", "MPEG4 / DivX / XviD"],
            "MOV": ["H.264 / AVC", "MPEG4 / DivX / XviD"],
            "AVI": ["H.264 / AVC", "MPEG4 / DivX / XviD"],
            "MPEG2 PS": ["H.264 / AVC", "MPEG4 / DivX / XviD", "MPEG2"],
            "MPEG2 TS": ["H.264 / AVC", "MPEG4 / DivX / XviD", "MPEG2"],
            "DVD (VOB)": ["MPEG2"],
            "Matroska": ["H.264 / AVC", "MPEG4 / DivX / XviD", "MPEG2", "VP8", "Theora"],
            "Ogg": ["Theora"],
            "FLV": ["H.264", "FLV / Spark / H.263"],
        }.get(container, ["No known codecs"])
        
        acodecs = {
            "WebM": ["Vorbis"],
            "MP4": ["AAC", "MP3"],
            "MOV": ["AAC", "MP3"],
            "AVI": ["AAC", "MP3", "Vorbis"],
            "MPEG2 PS": ["AAC", "MP3"],
            "MPEG2 TS": ["AAC", "MP3"],
            "DVD (VOB)": ["MP3"],
            "Matroska": ["AAC", "MP3", "Vorbis"],
            "Ogg": ["Vorbis"],
            "FLV": ["MP3"],
        }.get(container, ["No known codecs"])
        
        for widget, codecs in [(self.video_codec, vcodecs), (self.audio_codec, acodecs)]:
            iter = widget.get_active_iter()
            model = widget.get_model()
            selected = iter and model.get_value(iter, 0) or ""
            new_selected = 0
            model.clear()
            
            for i, codec in enumerate(codecs):
                iter = model.append()
                model.set_value(iter, 0, codec)
                if codec == selected:
                    new_selected = i
                    
            widget.set_active(new_selected)
    
    def on_vcodec_changed(self, widget):
        iter = self.video_codec.get_active_iter()
        vcodec = iter and self.video_codec.get_model().get_value(iter, 0) or None
        
        if vcodec and self.ENCODER_TO_VCODEC[self.preset.vcodec.name] != vcodec:
            self.preset.vcodec.name = self.VCODEC_TO_ENCODER[vcodec]
            self.video_options.set_text({
                "VP8": "quality=6 threads=%(threads)s speed=2",
                "H.264 / AVC": "pass=qual quantizer=21 me=umh subme=6 ref=3 threads=0",
                "MPEG4 / DivX / XviD": "pass=quant quantizer=5 max-bframes=2 trellis=true",
                "MPEG2": "format=3 quantisation=5",
                "FLV / Spark / H.263": "bitrate=512000",
            }.get(vcodec, ""))
    
    def on_width_min_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.width[0] = value
        
        if self.width_max.get_value() < value:
            self.width_max.set_value(value)
    
    def on_width_max_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.width[1] = value
        
        if self.width_min.get_value() > value:
            self.width_min.set_value(value)
        
        self.emit("changed")
    
    def on_height_min_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.height[0] = value
        
        if self.height_max.get_value() < value:
            self.height_max.set_value(value)
    
    def on_height_max_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.height[1] = value
        
        if self.height_min.get_value() > value:
            self.height_min.set_value(value)
        
        self.emit("changed")
    
    def on_framerate_min_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.rate[0] = value
        
        if self.framerate_max.get_value() < value:
            self.framerate_max.set_value(value)
    
    def on_framerate_max_changed(self, widget):
        value = widget.get_value()
        self.preset.vcodec.framerate[1] = value
        
        if self.framerate_min.get_value() > value:
            self.framerate_min.set_value(value)
    
    def on_effect_changed(self, widget):
        iter = self.effect.get_active_iter()
        effect = iter and self.effect.get_model().get_value(iter, 0) or None
        
        if effect:
            self.preset.vcodec.transform = self.EFFECT_TO_ELEMENTS[effect]
    
    def on_acodec_changed(self, widget):
        iter = self.audio_codec.get_active_iter()
        acodec = iter and self.audio_codec.get_model().get_value(iter, 0) or None
        
        if acodec and self.ENCODER_TO_ACODEC[self.preset.acodec.name] != acodec:
            self.preset.acodec.name = self.ACODEC_TO_ENCODER[acodec]
            self.audio_options.set_text({
                "Vorbis": "quality=0.5",
                "AAC": "profile=4 bitrate=128000",
                "MP3": "vbr=new vbr-quality=4",
            }.get(vcodec, ""))
    
    def on_channels_min_changed(self, widget):
        value = widget.get_value()
        self.preset.acodec.channels[0] = value
        
        if self.channels_max.get_value() < value:
            self.channels_max.set_value(value)
    
    def on_channels_max_changed(self, widget):
        value = widget.get_value()
        self.preset.acodec.channels[1] = value
        
        if self.channels_min.get_value() > value:
            self.channels_min.set_value(value)
    
    def on_vcodec_help_clicked(self, widget):
        iter = self.video_codec.get_active_iter()
        vcodec = iter and self.video_codec.get_model().get_value(iter, 0) or None
        self.on_codec_help(vcodec)
    
    def on_acodec_help_clicked(self, widget):
        iter = self.audio_codec.get_active_iter()
        acodec = iter and self.audio_codec.get_model().get_value(iter, 0) or None
        self.on_codec_help(acodec)
    
    def on_codec_help(self, codec):
        try:
            html_path = arista.utils.get_path("help", "%s.html" % codec.split(" ")[0].lower())
        except IOError:
            html_path = arista.utils.get_path("help", "404.html")
        
        html_path = "file://" + html_path
        
        if webkit:
            CodecHelpDialog(html_path)
        else:
            webbrowser.open(html_path)

gobject.type_register(PresetDialog)

class CodecHelpDialog(object):
    """
        Arista Codec Help Dialog
        ========================
        A dialog showing various options for codecs.
    """
    def __init__(self, html_path):
        ui_path = arista.utils.get_path("ui", "codec.ui")
        
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        
        self.window = self.builder.get_object("codec_dialog")
        
        # Add web view to dialog
        scrolled_window = self.builder.get_object("scrolledwindow")
        self.webkit = webkit.WebView()
        scrolled_window.add(self.webkit)
        
        # Load documentation for specific codec
        self.webkit.load_uri(html_path)
        
        self.builder.connect_signals(self)
        
        self.window.show_all()
    
    def on_close(self, widget):
        self.window.destroy()

class AboutDialog(object):
    """
        Arista About Dialog
        ===================
        A simple about dialog.
    """
    def __init__(self):
        ui_path = arista.utils.get_path("ui", "about.ui")
        
        self.builder = gtk.Builder()
        self.builder.add_from_file(ui_path)
        
        self.window = self.builder.get_object("about_dialog")
        
        self.builder.connect_signals(self)
        
        self.window.show_all()
    
    def on_close(self, widget, response):
        """
            Close was clicked, remove the window.
        """
        self.window.destroy()

if __name__ == "__main__":
    parser = OptionParser(usage = _("%prog [options] [file1 file2 file3 ...]"),
                          version = _("Arista Transcoder GUI " + \
                                      arista.__version__))
    parser.add_option("-v", "--verbose", dest = "verbose",
                      action = "store_true", default = False,
                      help = _("Show verbose (debug) output"))
    parser.add_option("-p", "--preset", dest = "preset", default = None,
                      help = _("Preset to encode to [default]"))
    parser.add_option("-d", "--device", dest = "device", default = "computer",
                      help = _("Device to encode to [computer]"))
    parser.add_option("-s", "--simple", dest = "simple", action = "store_true",
                      default = False, help = _("Simple UI"))
    
    options, args = parser.parse_args()
    
    options.files = args
    
    logging.basicConfig(level = options.verbose and logging.DEBUG \
                        or logging.INFO, format = "%(name)s [%(lineno)d]: " \
                        "%(levelname)s %(message)s")
    
    # FIXME: OMGWTFBBQ gstreamer hijacks sys.argv unless we import AFTER we use
    # the optionparser stuff above...
    # This seems to be fixed http://bugzilla.gnome.org/show_bug.cgi?id=425847
    # but in my testing it is NOT. Leaving hacks for now.
    import gst
    import gst.pbutils
    
    arista.init()
    
    lc_path = arista.utils.get_path("locale", default = "")
    if lc_path:
        if hasattr(gettext, "bindtextdomain"):
            gettext.bindtextdomain("arista", lc_path)
        if hasattr(locale, "bindtextdomain"):
            locale.bindtextdomain("arista", lc_path)
    
    if hasattr(gettext, "bind_textdomain_codeset"):
        gettext.bind_textdomain_codeset("arista", "UTF-8")
    if hasattr(locale, "bind_textdomain_codeset"):
        locale.bind_textdomain_codeset("arista", "UTF-8")
    
    if hasattr(gettext, "textdomain"):
        gettext.textdomain("arista")
    if hasattr(locale, "textdomain"):
        locale.textdomain("arista")
    
    gtk.gdk.threads_init()
    
    # Set the default icon for all windows
    icon_path = arista.utils.get_path("ui", "icon.svg")
    gtk.window_set_default_icon_from_file(icon_path)
    
    main = MainWindow(options)
    
    client = gconf.client_get_default()
    try:
        check_updates = client.get_value(CONFIG_PATH + "/check_updates")
    except ValueError:
        check_updates = DEFAULT_CHECK_UPDATES
    
    if check_updates:
        update_checker = UpdateChecker(main)
        update_checker.start()
    
    gtk.main()

